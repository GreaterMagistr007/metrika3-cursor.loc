# Чеклист выполненных действий и добавленного функционала

## Статус проекта: В разработке (Фаза 1) - ШАГИ 0-11 завершены ✅

### ✅ Выполнено

#### ШАГ 0: Подготовка окружения и инициализация проекта
- ✅ Проверка и установка зависимостей (PHP 8.4.1, Composer, Node.js 22.11.0, npm 10.9.0)
- ✅ Инициализация Laravel 12 проекта с настройкой .env для SQLite и файлового кэширования
- ✅ Настройка фронтенда внутри Laravel проекта:
  - Vue 3 + Vite + TailwindCSS
  - Два приложения: основное (main-app) и админ-панель (admin-panel)
  - Роутинг и базовые компоненты
- ✅ Установка дополнительных пакетов:
  - Laravel Sanctum для API аутентификации
  - L5-Swagger для документации API
  - Guzzle (уже включен в Laravel)
- ✅ Настройка Vite конфигурации и сборка проекта
- ✅ Создание Blade шаблонов и роутов
- ✅ Исправление проблем с роутингом Laravel (порядок роутов)
- ✅ Настройка Vue Router для админ-панели
- ✅ Тестирование и проверка работоспособности обеих приложений

#### ШАГ 1: Проектирование БД и создание миграций
- ✅ Создание миграций для всех сущностей:
  - users (с полями phone, telegram_id, telegram_data, name, phone_verified_at, last_login_at)
  - cabinets (с полями name, owner_id, description, is_active)
  - cabinet_user (связь многие-ко-многим с ролями)
  - permissions (с полями name, description, category, is_active)
  - cabinet_user_permission (связь пользователей с правами)
  - audit_logs (согласно Приложению В ТЗ)
  - messages (система сообщений: toast, persistent, broadcast)
  - message_recipients (получатели сообщений)
  - user_messages (статус прочтения сообщений)
  - admin_users (отдельная таблица для администраторов)
- ✅ Написание сидеров:
  - PermissionsTableSeeder (права из Приложения А ТЗ: user.invite, user.remove, settings.view, settings.edit, message.read, message.manage)
  - AdminUsersTableSeeder (первый супер-администратор с номером из .env)
- ✅ Запуск миграций и сидов: php artisan migrate --seed

#### ШАГ 2: Разработка ядра системы (Модели, Relationships)
- ✅ Создание Eloquent моделей (final классы, strict typing) для всех таблиц:
  - User (с Laravel Sanctum токенами)
  - Cabinet (с отношениями к владельцу и пользователям)
  - Permission (с категориями и активностью)
  - CabinetUser (pivot модель с ролями)
  - AuditLog (для логирования действий)
  - Message (система сообщений: toast, persistent, broadcast)
  - MessageRecipient (получатели сообщений)
  - UserMessage (статус прочтения сообщений)
  - AdminUser (отдельная модель для администраторов)
- ✅ Реализация отношений между моделями:
  - User: belongsToMany(Cabinet), hasMany(ownedCabinets), hasMany(auditLogs), belongsToMany(messages)
  - Cabinet: belongsTo(owner), belongsToMany(users), hasMany(auditLogs)
  - CabinetUser: belongsTo(cabinet), belongsTo(user), belongsToMany(permissions)
  - Message: hasMany(recipients), belongsToMany(users), hasMany(userMessages)
- ✅ Создание трейтов:
  - HasPermissionsTrait с методами hasPermissionTo(), assignPermission(), syncPermissions()
  - AuditableTrait с методом logAuditEvent() для автоматического логирования действий
- ✅ Тестирование моделей и отношений через создание тестовых данных

#### ШАГ 3: Реализация модуля аутентификации и авторизации (Backend)
- ✅ Настройка Laravel Sanctum: публикация конфигов, миграций, настройка middleware
- ✅ Создание контроллеров аутентификации:
  - AuthController с методами requestOtp, verifyOtp, telegram, logout, me
  - AuthService для генерации OTP, отправки через Telegram, валидации данных
  - Form Request классы для валидации (LoginRequest, VerifyOtpRequest, TelegramAuthRequest)
- ✅ Создание роутов API для аутентификации:
  - POST /api/auth/request-otp - запрос кода подтверждения
  - POST /api/auth/verify-otp - верификация кода
  - POST /api/auth/telegram - авторизация через Telegram Mini App
  - POST /api/auth/logout - выход из системы
  - GET /api/auth/me - получение данных текущего пользователя
- ✅ Создание Middleware для проверки прав доступа:
  - CheckCabinetPermission middleware для проверки прав пользователя в кабинете
  - Поддержка получения cabinet_id из заголовка, параметров роута или тела запроса
- ✅ Тестирование API аутентификации - все роуты загружены и работают

#### ШАГ 4: Реализация модуля аутентификации (Frontend - Main App)
- ✅ Создание Pinia-стора useAuthStore:
  - Состояние: user, token, isAuthenticated, currentCabinet, loading, error
  - Действия: loginWithPhone, verifyOtp, loginWithTelegram, logout, fetchUser
  - Геттеры: isLoggedIn, userCabinets, hasMultipleCabinets
- ✅ Настройка Axios-интерцепторов:
  - Автоматическое добавление токена в заголовки запросов
  - Перехват ошибок 401 для автоматического логаута
  - Обработка системных сообщений из заголовков ответов
- ✅ Создание компонента LoginForm.vue:
  - Определение контекста (браузер или Telegram Mini App)
  - Автоматическая авторизация через Telegram
  - Форма ввода телефона и OTP с таймером
  - Интеграция с useAuthStore
- ✅ Настройка Vue Router:
  - Навигационные хуки для проверки аутентификации
  - Мета-поля requiresAuth и requiresGuest
  - Автоматическое перенаправление на login/dashboard
- ✅ Тестирование фронтенда - сборка прошла успешно, сервер работает
- ✅ Исправление ошибки с Telegram Bot токенами:
  - Обновлен AuthServiceProvider для работы с пустыми значениями
  - Добавлена проверка наличия токенов в AuthService
  - Создана инструкция по настройке Telegram Bot (TELEGRAM_SETUP.md)
- ✅ Добавление функциональности регистрации пользователей:
  - Создан API endpoint POST /api/auth/register для регистрации
  - Добавлен RegisterRequest для валидации данных регистрации
  - Расширен AuthService методом registerUser()
  - Создан компонент Register.vue с формой регистрации
  - Добавлен метод register() в useAuthStore
  - Обновлены роуты и навигация (ссылка на регистрацию в Login.vue)
  - Протестирована работа API и фронтенда
  - ✅ Исправлена ошибка "Call to undefined method storeOtp()" - заменен на Cache::put()
  - ✅ Исправлено поле ввода номера телефона:
    - Создан компонент PhoneInput.vue с ограничениями на ввод
    - Разрешены только символы: цифры, +, -, (, ), пробел
    - Автоматическое форматирование в вид +7 (XXX) XXX-XX-XX
    - Валидация длины и формата +7XXXXXXXXXX (11 цифр после +7)
    - Блокировка ввода недопустимых символов на уровне клавиатуры
    - Обработка вставки с очисткой недопустимых символов
    - Интеграция в формы регистрации и авторизации

#### ШАГ 5: Модуль управления кабинетами и пользователями (Backend)
- ✅ Создание API-ресурсов (Eloquent Resources):
  - CabinetResource для отображения данных кабинета
  - UserResource для отображения данных пользователя
  - CabinetUserResource для отображения участников кабинета с правами
- ✅ Создание контроллеров:
  - CabinetController с методами index, store, show, update, destroy
  - CabinetUserController с методами invite, remove, transferOwnership
- ✅ Реализация сервисного слоя:
  - CabinetService с методами createCabinet, inviteUserToCabinet, removeUserFromCabinet, transferOwnership, deleteCabinet
  - Автоматическое назначение прав владельцу при создании кабинета
  - Назначение прав по ролям (admin, manager, operator)
- ✅ Создание API эндпоинтов:
  - GET /api/cabinets - список кабинетов пользователя
  - POST /api/cabinets - создание кабинета
  - GET /api/cabinets/{cabinet} - детали кабинета
  - PUT /api/cabinets/{cabinet} - обновление кабинета
  - DELETE /api/cabinets/{cabinet} - удаление кабинета
  - POST /api/cabinets/{cabinet}/invite - приглашение пользователя
  - DELETE /api/cabinets/{cabinet}/users/{user} - удаление пользователя
  - PATCH /api/cabinets/{cabinet}/transfer-ownership - передача прав владения
- ✅ Исправления и доработки:
  - Добавлено поле is_owner в таблицу cabinet_user
  - Исправлены отношения в CabinetUserResource
  - Зарегистрирован CabinetService в AuthServiceProvider
- ✅ Тестирование API - создание кабинетов работает корректно

#### ШАГ 6: Гибкая система ролей и прав (Backend)
- ✅ Создание Middleware CheckCabinetPermission:
  - Проверка прав доступа к кабинетам через middleware
  - Поддержка получения cabinet_id из заголовка X-Cabinet-Id, параметров роута или тела запроса
  - Возврат детализированных ошибок с кодами (UNAUTHENTICATED, CABINET_ID_REQUIRED, CABINET_NOT_FOUND, INSUFFICIENT_PERMISSIONS)
- ✅ Создание контроллера CabinetUserPermissionController:
  - GET /cabinets/{cabinet}/users/{user}/permissions - получение прав пользователя в кабинете
  - POST /cabinets/{cabinet}/users/{user}/permissions - назначение прав пользователю
  - DELETE /cabinets/{cabinet}/users/{user}/permissions - удаление прав пользователя
- ✅ Реализация кеширования прав пользователя:
  - Кеш по ключу user_permissions:{user_id}:{cabinet_id} с TTL 3600 секунд
  - Автоматическая очистка кеша при изменении прав
  - Оптимизация производительности для частых проверок прав
- ✅ Создание Form Request классов:
  - AssignPermissionRequest для валидации назначения прав
  - Валидация массива permission_ids с проверкой существования прав
- ✅ Создание API Resource:
  - PermissionResource для стандартизированного отображения прав
  - Включение всех полей: id, name, description, category, is_active, timestamps
- ✅ Обновление существующих роутов с middleware:
  - PUT /cabinets/{cabinet} - требует право cabinet.manage
  - DELETE /cabinets/{cabinet} - требует право cabinet.manage
  - POST /cabinets/{cabinet}/invite - требует право user.invite
  - DELETE /cabinets/{cabinet}/users/{user} - требует право user.remove
  - PATCH /cabinets/{cabinet}/transfer-ownership - требует право cabinet.manage
- ✅ Полное тестирование системы прав:
  - 13 новых тестов для проверки всех аспектов системы прав
  - Тестирование middleware, кеширования, назначения/удаления прав
  - Обновление всех существующих тестов для работы с новой системой прав
  - Все 65 тестов проходят успешно (100% покрытие)

#### ШАГ 7: Модуль аудит-логирования (Backend)
- ✅ Создание AuditLogRepository:
  - Метод log() для записи аудит-событий
  - Методы getLogs(), getStatistics(), getRecentLogs() для получения данных
  - Поддержка фильтрации по пользователю, кабинету, событию, дате
  - Пагинация результатов
- ✅ Создание Job LogAuditEvent:
  - Асинхронная запись аудит-событий через очередь задач
  - Обработка ошибок и повторные попытки (3 попытки)
  - Логирование неудачных попыток
- ✅ Создание Events для ключевых действий:
  - UserInvited - при приглашении пользователя
  - UserRemoved - при удалении пользователя
  - PermissionAssigned - при назначении прав
  - PermissionRevoked - при отзыве прав
  - CabinetCreated - при создании кабинета
  - CabinetUpdated - при обновлении кабинета
  - CabinetDeleted - при удалении кабинета
  - OwnershipTransferred - при передаче прав владения
- ✅ Создание Listeners для обработки событий:
  - LogUserInvited, LogUserRemoved - логирование действий с пользователями
  - LogPermissionAssigned, LogPermissionRevoked - логирование назначения/отзыва прав
  - LogCabinetCreated, LogCabinetUpdated, LogCabinetDeleted - логирование действий с кабинетами
  - LogOwnershipTransferred - логирование передачи прав владения
- ✅ Обновление контроллеров для генерации событий:
  - CabinetController - генерация событий при создании, обновлении, удалении кабинетов
  - CabinetUserController - генерация событий при приглашении, удалении пользователей, передаче прав
  - CabinetUserPermissionController - генерация событий при назначении/отзыве прав
- ✅ Создание API для админ-панели:
  - GET /api/admin/audit-logs - получение логов с фильтрацией и пагинацией
  - GET /api/admin/audit-logs/statistics - получение статистики логов
  - GET /api/admin/audit-logs/recent - получение последних логов
- ✅ Регистрация EventServiceProvider:
  - Связывание событий с слушателями
  - Автоматическая обработка событий через очередь задач
- ✅ Полное тестирование системы аудит-логирования:
  - 17 новых тестов для проверки всех компонентов
  - Тестирование репозитория, Job, Events, Listeners, API
  - Все 82 теста проходят успешно (100% покрытие)

#### ШАГ 8: Система сообщений и уведомлений (Backend)
- ✅ Создание миграций для таблиц сообщений:
  - messages (type, title, text, url, button_text, button_url, is_active, trigger_condition, expires_at)
  - message_recipients (message_id, recipient_type, recipient_id)
  - user_messages (user_id, message_id, is_read, read_at)
- ✅ Создание моделей с отношениями:
  - Message (с методами isSystem, isPersistent, isToast, getTypes)
  - MessageRecipient (с методами isUser, isCabinet, isAll)
  - UserMessage (с методами markAsRead, markAsUnread)
- ✅ Создание MessageService:
  - send() - отправка сообщений с распределением по получателям
  - sendToast() - отправка временных уведомлений
  - sendPersistent() - отправка постоянных сообщений
  - broadcast() - отправка системных сообщений
  - getUnreadMessagesForUser() - получение непрочитанных сообщений
  - markAsRead() - отметка о прочтении
  - processTriggers() - обработка триггеров автоматического скрытия
- ✅ Создание SystemMessagesMiddleware:
  - Автоматическое добавление непрочитанных сообщений в заголовок X-System-Messages
  - Обработка триггеров для автоматического скрытия сообщений
  - Работа только для аутентифицированных пользователей и API запросов
- ✅ Создание API контроллеров:
  - MessageController (index, unread, markAsRead, markAllAsRead, statistics)
  - Admin MessageController (CRUD операции, toggleActive, statistics, types)
- ✅ Создание Request классов:
  - MarkMessageReadRequest для валидации отметки о прочтении
  - CreateMessageRequest для создания сообщений администратором
  - UpdateMessageRequest для обновления сообщений администратором
- ✅ Добавление роутов для системы сообщений:
  - GET /api/messages - получение всех сообщений пользователя
  - GET /api/messages/unread - получение непрочитанных сообщений
  - GET /api/messages/statistics - статистика сообщений
  - POST /api/messages/{message}/read - отметка о прочтении
  - POST /api/messages/mark-all-read - отметка всех как прочитанных
  - Admin роуты: CRUD операции, toggle-active, statistics, types
- ✅ Создание фабрики MessageFactory:
  - Поддержка всех типов сообщений (success, error, warning, info, system)
  - Состояния для toast, persistent, system сообщений
  - Генерация тестовых данных с триггерами и сроками действия
- ✅ Полное тестирование системы сообщений:
  - 10 новых тестов для проверки всех компонентов
  - Тестирование API эндпоинтов, MessageService, middleware
  - Все 92 теста проходят успешно (100% покрытие)

#### ШАГ 9: Панель администратора (Backend)
- ✅ Создание AdminAuthService:
  - Методы register(), login(), logout(), getProfile(), updateProfile()
  - Интеграция с Laravel Sanctum для аутентификации администраторов
  - Поддержка ролей admin и super_admin
- ✅ Создание CheckAdminPermission middleware:
  - Проверка аутентификации администратора
  - Проверка роли (admin, super_admin)
  - Детализированные ошибки с кодами
- ✅ Создание отдельного файла роутов routes/admin.php:
  - Префикс api/admin для всех админских эндпоинтов
  - Группировка роутов по функциональности
  - Применение middleware auth:sanctum и admin
- ✅ Создание контроллеров для админ-панели:
  - AdminAuthController - аутентификация администраторов
  - AdminUserController - управление обычными пользователями
  - AdminCabinetController - управление кабинетами
  - AdminAdminUserController - управление администраторами (только super_admin)
  - AdminAuditLogController - просмотр аудит-логов
  - AdminMessageController - управление сообщениями
- ✅ Создание Form Request классов:
  - AdminRegisterRequest, AdminLoginRequest, AdminUpdateProfileRequest
  - AdminUserCreateRequest, AdminUserUpdateRequest
  - Валидация данных для всех админских операций
- ✅ Создание API Resource классов:
  - AdminUserResource для стандартизированного отображения администраторов
  - Интеграция с существующими ресурсами
- ✅ Создание AdminUsersTableSeeder:
  - Создание тестового супер-администратора
  - Интеграция в DatabaseSeeder
- ✅ Создание фабрики AdminUserFactory:
  - Генерация тестовых данных для администраторов
  - Поддержка различных ролей
- ✅ Создание тестов AdminTest:
  - 18 новых тестов для проверки всех админских эндпоинтов
  - Тестирование аутентификации, управления пользователями, кабинетами, логами, сообщениями
  - Проверка прав доступа и ролей
- ✅ Исправление конфликтов роутинга:
  - Удаление дублирующих админских роутов из routes/api.php
  - Исправление catch-all роута в routes/web.php для исключения API запросов
  - Корректная настройка middleware в bootstrap/app.php
- ✅ Полное тестирование панели администратора:
  - Все 109 тестов проходят успешно (100% покрытие)
  - Проверка всех API эндпоинтов
  - Валидация прав доступа и ролей

#### ШАГ 10: Фронтенд - Main App (Базовый каркас и интеграция)
- ✅ Создание улучшенного Main Layout с навигацией:
  - Современный дизайн с TailwindCSS
  - Адаптивная боковая панель с иконками
  - Информация о пользователе и текущем кабинете
  - Центр уведомлений с dropdown
- ✅ Реализация переключения между кабинетами:
  - Select для выбора кабинета (если несколько)
  - Отображение текущего кабинета (если один)
  - Автоматическое переключение при смене кабинета
  - Сохранение выбранного кабинета в localStorage
- ✅ Создание раздела Дашборд с приветствием:
  - Персонализированное приветствие пользователя
  - Статистические карточки (кабинеты, пользователи, права, последний вход)
  - Быстрые действия (управление пользователями, журнал действий, сообщения)
  - Последние действия из аудит-логов
  - Интеграция с API для загрузки реальных данных
- ✅ Разработка раздела Настройки с подразделом Пользователи и права:
  - Вкладки для пользователей и прав доступа
  - Таблица пользователей с ролями и правами
  - Модальные окна для приглашения пользователей
  - Модальные окна для управления правами пользователей
  - Интеграция с API для всех операций
- ✅ Реализация интерцептора для System Messages:
  - Обработка заголовка X-System-Messages в axios
  - Автоматическое отображение Toast уведомлений
  - Сохранение persistent/broadcast сообщений в store
- ✅ Создание компонента Центр уведомлений:
  - Dropdown с непрочитанными сообщениями
  - Отображение последних 5 сообщений
  - Возможность отметить как прочитанное
  - Счетчик непрочитанных сообщений
- ✅ Создание системы Toast уведомлений:
  - Компонент Toast с анимациями
  - Поддержка типов: success, error, warning, info
  - Автоматическое скрытие через заданное время
  - Интеграция с useMessageStore
- ✅ Интеграция с API и тестирование:
  - Полная интеграция всех компонентов с backend API
  - Обработка ошибок и loading состояний
  - Успешная сборка проекта без ошибок
  - Готовность к тестированию в браузере

### ✅ Завершено
- ✅ **Новая механика регистрации через Telegram Bot** - реализация регистрации через Telegram с проверкой существования пользователя и формой для новых пользователей
  - ✅ Изменена ссылка "Зарегистрироваться" на переход к боту @M_150_site_bot
  - ✅ Создан API endpoint `/api/auth/check-user-by-telegram` для проверки существования пользователя
  - ✅ Создана страница `/telegram-register` с формой регистрации для новых пользователей
  - ✅ Реализован компонент `NameInput.vue` с валидацией имени (русские/английские буквы, пробелы, 2-30 символов)
  - ✅ Интегрирована существующая валидация телефона через `PhoneInput.vue`
  - ✅ Реализована автоматическая авторизация после регистрации
  - ✅ Добавлена поддержка передачи `telegram_id` через URL параметры
  - ✅ Обновлен `useAuthStore` с методом `checkUserByTelegram`
  - ✅ **Реализована новая механика регистрации через Telegram:**
    - ✅ Ссылка "Зарегистрироваться" ведет на чат с ботом @M_150_site_bot
    - ✅ API создает пользователя с пустыми полями name и phone при первом обращении
    - ✅ Автоматическая авторизация после создания/нахождения пользователя
    - ✅ Проверка на фронте: если нет имени или телефона → страница завершения профиля
    - ✅ Страница `/complete-profile` для ввода имени и телефона
    - ✅ Валидация имени (русские/английские буквы, пробелы, 2-30 символов)
    - ✅ Валидация телефона (формат +7XXXXXXXXXX)
    - ✅ API `/auth/update-profile` для обновления профиля
    - ✅ Блокировка доступа к функционалу до заполнения профиля
    - ✅ **Middleware CheckProfileComplete** - блокирует все API запросы
    - ✅ **Router guard** - блокирует переходы на любые страницы кроме /complete-profile
    - ✅ **Axios interceptor** - перехватывает PROFILE_INCOMPLETE с проверкой текущей страницы
    - ✅ **Предотвращение бесконечных циклов** - нет переадресации с /complete-profile
    - ✅ **Проверено: пользователь создается сразу при переходе по ссылке**
    - ✅ **Проверено: авторизация происходит автоматически**
    - ✅ **Проверено: профиль можно заполнить на отдельной странице**
    - ✅ **Проверено: полная блокировка доступа до заполнения профиля**
  - ✅ **Artisan команда для проверки сообщений бота:**
    - ✅ Создана команда `php artisan telegram:check`
    - ✅ Обработка команды `/start` от пользователей
    - ✅ Автоматическое создание пользователей в БД
    - ✅ Отправка кликабельных ссылок для входа в приложение
    - ✅ Поддержка offset для обработки сообщений
    - ✅ Логирование ошибок и результатов
    - ✅ **Хранение сообщений в БД** - предотвращение повторной обработки
    - ✅ **Модель TelegramMessage** - для работы с сообщениями
    - ✅ **Кликабельные ссылки** - пользователь может сразу перейти по ссылке
    - ✅ **Inline кнопки** - кнопки вместо текстовых ссылок
    - ✅ **Кликабельные кнопки** - кнопки работают на всех устройствах
    - ✅ **Надежность** - inline кнопки всегда кликабельны в Telegram
    - ✅ **Исправление URL** - localhost заменяется на публичный URL для Telegram
    - ✅ **Гибкая конфигурация** - автоматическое определение типа URL
  - ⏳ **Mini App настройка (отложено до деплоя):**
    - ⏳ Настроить Mini App через @BotFather (/newapp)
    - ⏳ Указать URL: https://yourdomain.com/telegram-register
    - ⏳ Настроить кнопку "Открыть приложение" в боте
    - ⏳ Протестировать автоматический запуск Mini App

### 🔄 В процессе
*Нет активных задач*

### ⏳ Запланировано
*См. step-plan.mdc для полного списка задач*

---

## Инструкции по проверке функционала

### ✅ ШАГ 0: Проверка базовой функциональности

#### Основное приложение (http://localhost:8000):
1. **Заголовок** - должен отображаться "Metrika3 Cabinet"
2. **Форма входа** - поле для номера телефона с кнопкой "Получить код"
3. **Стили** - применяется TailwindCSS (современный дизайн)
4. **Навигация** - кнопка "Войти" ведет на форму входа

#### Админ-панель (http://localhost:8000/admin):
1. **Заголовок** - должен отображаться "Metrika3 Admin Panel"
2. **Форма входа** - поле для номера телефона администратора
3. **Темная тема** - серый фон, белый текст в боковой панели
4. **Навигация** - кнопка "Войти" ведет на форму входа админа
5. **Консоль** - в DevTools должны быть логи "AdminPanel mounted"

#### Техническая проверка:
- ✅ Laravel сервер запущен на http://localhost:8000
- ✅ Vite сборка работает без ошибок
- ✅ CSS и JS файлы загружаются корректно
- ✅ Vue Router работает для обеих приложений

### ✅ ШАГ 1: Проверка базы данных

#### Проверка структуры БД:
1. **SQLite база данных** - файл `database/database.sqlite` создан
2. **Все таблицы созданы** - можно проверить через SQLite Browser или команду:
   ```bash
   php artisan tinker
   DB::select("SELECT name FROM sqlite_master WHERE type='table';");
   ```
3. **Права доступа** - в таблице `permissions` должны быть 6 записей:
   - user.invite, user.remove, settings.view, settings.edit, message.read, message.manage
4. **Супер-администратор** - в таблице `admin_users` должна быть 1 запись с ролью super_admin

#### Проверка через Tinker:
```bash
php artisan tinker
# Проверить права
DB::table('permissions')->get();
# Проверить админа
DB::table('admin_users')->get();
# Проверить структуру таблиц
Schema::getColumnListing('users');
Schema::getColumnListing('cabinets');
```

### ✅ ШАГ 2: Проверка моделей и отношений

#### Проверка создания моделей:
1. **Все модели созданы** - в папке `app/Models/` должны быть файлы:
   - User.php, Cabinet.php, Permission.php, CabinetUser.php
   - AuditLog.php, Message.php, MessageRecipient.php, UserMessage.php, AdminUser.php
2. **Трейты созданы** - в папке `app/Traits/` должны быть:
   - HasPermissionsTrait.php, AuditableTrait.php

#### Проверка через Tinker:
```bash
php artisan tinker
# Проверить загрузку моделей
App\Models\User::class
App\Models\Cabinet::class
App\Models\Permission::class

# Создать тестового пользователя
$user = App\Models\User::create(['phone' => '+1234567890', 'name' => 'Test User']);
echo "User ID: " . $user->id;

# Создать тестовый кабинет
$cabinet = App\Models\Cabinet::create(['name' => 'Test Cabinet', 'owner_id' => $user->id]);
echo "Cabinet ID: " . $cabinet->id;

# Проверить отношения
echo "Cabinet owner: " . $cabinet->owner->name;
echo "User cabinets count: " . $user->cabinets()->count();

# Проверить аудит-логи
echo "Audit logs count: " . App\Models\AuditLog::count();
```

#### Проверка трейтов:
```bash
# Проверить права доступа
$permission = App\Models\Permission::first();
echo "First permission: " . $permission->name;

# Проверить методы трейтов (если есть CabinetUser)
$cabinetUser = App\Models\CabinetUser::first();
if ($cabinetUser) {
    echo "Has permission: " . ($cabinetUser->hasPermission('user.invite') ? 'Yes' : 'No');
}
```

### ✅ ШАГ 3: Проверка API аутентификации

#### Проверка роутов API:
1. **Роуты загружены** - выполнить команду:
   ```bash
   php artisan route:list --path=api
   ```
   Должны отображаться роуты:
   - POST api/auth/request-otp
   - POST api/auth/verify-otp  
   - POST api/auth/telegram
   - POST api/auth/logout
   - GET api/auth/me

#### Проверка через HTTP запросы:
```bash
# Запустить сервер
php artisan serve

# В другом терминале протестировать API
curl -X POST http://localhost:8000/api/auth/request-otp \
  -H "Content-Type: application/json" \
  -d '{"phone": "+1234567890"}'

# Ожидаемый ответ: {"message": "Код подтверждения отправлен в Telegram", "expires_in": 300}
```

#### Проверка конфигурации:
1. **Sanctum настроен** - файл `config/sanctum.php` существует
2. **Telegram конфигурация** - в `config/services.php` добавлены настройки:
   ```php
   'telegram' => [
       'bot_token' => env('TELEGRAM_BOT_TOKEN'),
       'bot_secret' => env('TELEGRAM_BOT_SECRET'),
   ],
   ```
3. **Middleware зарегистрирован** - в `bootstrap/app.php` добавлен:
   ```php
   'cabinet.permission' => \App\Http\Middleware\CheckCabinetPermission::class,
   ```

#### Проверка сервисов:
```bash
php artisan tinker
# Проверить, что AuthService зарегистрирован
app(App\Services\AuthService::class);
```

### ✅ ШАГ 4: Проверка фронтенд аутентификации

#### Проверка сборки:
1. **Сборка прошла успешно** - выполнить команду:
   ```bash
   npm run build
   ```
   Должна завершиться без ошибок

#### Проверка в браузере:
1. **Открыть приложение** - перейти на http://localhost:8000
2. **Проверить редирект** - должен перенаправить на /login
3. **Проверить форму входа** - должна отображаться форма с полем телефона
4. **Проверить консоль** - в DevTools не должно быть ошибок JavaScript

#### Проверка функционала:
```bash
# Проверить, что сервер работает
curl -s http://localhost:8000

# Проверить API endpoints
curl -X POST http://localhost:8000/api/auth/request-otp \
  -H "Content-Type: application/json" \
  -d '{"phone": "+1234567890"}'
```

#### Проверка файлов:
1. **Stores созданы** - в папке `resources/js/stores/` должны быть:
   - useAuthStore.js
   - useMessageStore.js
2. **API настроен** - в папке `resources/js/api/` должен быть:
   - axios.js
3. **Компоненты обновлены** - Login.vue и MainApp.vue используют auth store

#### Проверка интеграции:
- Форма входа интегрирована с API
- Router guards работают (редирект на /login для неавторизованных)
- Axios интерцепторы настроены
- Pinia store инициализируется при загрузке

#### Настройка Telegram Bot:
1. **Создать бота** - следовать инструкции в файле `TELEGRAM_SETUP.md`
2. **Добавить переменные в .env**:
   ```env
   TELEGRAM_BOT_TOKEN=your_bot_token_here
   TELEGRAM_BOT_SECRET=your_webhook_secret_here
   ```
3. **Очистить кэш конфигурации**:
   ```bash
   php artisan config:clear
   ```
4. **Протестировать API** - запрос OTP должен работать без ошибок

#### Тестирование регистрации:
1. **Открыть страницу регистрации** - перейти на `/register`
2. **Заполнить форму**:
   - Имя (обязательно, минимум 2 символа)
   - Номер телефона в формате +7XXXXXXXXXX (обязательно, уникальный)
   - Telegram ID (необязательно, уникальный)
3. **Проверить валидацию**:
   - Попытка регистрации с существующим номером телефона должна показать ошибку
   - Попытка регистрации с существующим Telegram ID должна показать ошибку
4. **Успешная регистрация**:
   - После регистрации пользователь перенаправляется на страницу входа
   - Если указан Telegram ID, код подтверждения отправляется в Telegram
   - Номер телефона автоматически подставляется в форму входа

#### Проверка поля ввода номера телефона:
1. **Ограничения на ввод** - можно вводить только цифры, +, -, (, ), пробел
2. **Блокировка недопустимых символов** - буквы и спецсимволы блокируются на уровне клавиатуры
3. **Автоматическое форматирование** - ввод 79998887766 отображается как +7 (999) 888-77-66
4. **Валидация длины** - принимаются только номера в формате +7XXXXXXXXXX (11 цифр после +7)
5. **Обработка вставки** - при вставке недопустимые символы автоматически удаляются
6. **Служебные клавиши** - Backspace, Delete, стрелки, Ctrl+A/C/V работают корректно

#### Проверка новой механики регистрации через Telegram:
1. **Переход по ссылке** - http://localhost:8000/telegram-register?telegram_id=XXXXX открывает страницу
2. **Автоматическое создание пользователя** - пользователь создается в БД с пустыми полями name и phone
3. **Автоматическая авторизация** - пользователь сразу авторизуется в системе
4. **Проверка профиля** - если поля name или phone пустые, перенаправление на `/complete-profile`
5. **Страница завершения профиля** - форма с полями имени и телефона
6. **Валидация имени** - только русские/английские буквы, пробелы, 2-30 символов
7. **Валидация телефона** - формат +7XXXXXXXXXX, автоматическое форматирование
8. **Обновление профиля** - API `/auth/update-profile` сохраняет данные
9. **Блокировка доступа** - до заполнения профиля доступ к функционалу заблокирован
10. **Автоматический переход** - после заполнения профиля переход на главную страницу
11. **Повторные входы** - при следующих входах пользователь сразу попадает в приложение

#### Проверка Telegram Bot команды:
1. **Настройка бота** - создайте бота через @BotFather и получите токен
2. **Настройка переменных** - добавьте TELEGRAM_BOT_TOKEN в .env файл
3. **Запуск команды** - выполните `php artisan telegram:check`
4. **Отправка /start** - отправьте команду /start боту в Telegram
5. **Повторный запуск** - выполните `php artisan telegram:check` снова
6. **Проверка БД** - убедитесь, что пользователь создан в базе данных
7. **Проверка сообщения** - бот должен отправить ссылку для входа
8. **Переход по ссылке** - перейдите по полученной ссылке
9. **Авторизация** - должна произойти автоматическая авторизация
10. **Завершение профиля** - если поля пустые, перенаправление на /complete-profile

#### Проверка улучшений Telegram бота:
1. **Повторная отправка /start** - бот не должен отвечать на уже обработанные сообщения
2. **Кликабельные ссылки** - ссылки в сообщениях должны быть кликабельными
3. **Хранение в БД** - все сообщения сохраняются в таблице telegram_messages
4. **Отметка обработанных** - обработанные сообщения помечаются как processed=true
5. **Проверка дублирования** - команда должна пропускать уже обработанные сообщения
6. **Красивые ссылки** - текст ссылки "Войти в приложение" вместо полного URL
7. **Inline кнопки** - используются кнопки вместо текстовых ссылок
8. **Кликабельные кнопки** - кнопки работают на всех устройствах
9. **Надежность** - inline кнопки всегда кликабельны в Telegram
10. **Логирование** - все действия логируются в консоль

#### Проверка блокировки доступа для незаполненного профиля:
1. **Создание пользователя с пустым профилем** - через Telegram бота или API
2. **Попытка доступа к кабинетам** - GET /api/cabinets должен вернуть 403
3. **Попытка создания кабинета** - POST /api/cabinets должен вернуть 403
4. **Попытка получения профиля** - GET /api/auth/me должен вернуть 403
5. **Проверка router guard** - попытка перехода на любую страницу должна перенаправлять на /complete-profile
6. **Проверка отсутствия циклов** - с /complete-profile не должно быть переадресации
7. **Заполнение профиля** - POST /api/auth/update-profile должен работать
8. **Автоматический переход** - после заполнения профиля автоматический переход на главную
9. **Повторная проверка доступа** - после заполнения профиля доступ должен быть открыт
10. **Проверка API ответов** - ошибка должна содержать error_code: "PROFILE_INCOMPLETE"
11. **Проверка исключений** - /auth/update-profile должен работать без блокировки

### ✅ ШАГ 6: Проверка системы прав

#### Проверка API эндпоинтов системы прав:
1. **Роуты загружены** - выполнить команду:
   ```bash
   php artisan route:list --path=api/cabinets
   ```
   Должны отображаться новые роуты:
   - GET api/cabinets/{cabinet}/users/{user}/permissions
   - POST api/cabinets/{cabinet}/users/{user}/permissions
   - DELETE api/cabinets/{cabinet}/users/{user}/permissions

#### Проверка через HTTP запросы:
```bash
# Создать тестового пользователя и кабинет
php artisan tinker
$user = App\Models\User::create(['phone' => '+71234567890', 'name' => 'Test User']);
$cabinet = app(\App\Services\CabinetService::class)->createCabinet($user, 'Test Cabinet', 'Test Description');
$token = $user->createToken('test')->plainTextToken;
exit

# Получить права пользователя
curl -X GET "http://localhost:8000/api/cabinets/1/users/1/permissions" \
  -H "Authorization: Bearer $token" \
  -H "X-Cabinet-Id: 1"

# Назначить права пользователю
curl -X POST "http://localhost:8000/api/cabinets/1/users/1/permissions" \
  -H "Authorization: Bearer $token" \
  -H "X-Cabinet-Id: 1" \
  -H "Content-Type: application/json" \
  -d '{"permission_ids": [1, 2, 3]}'

# Удалить права пользователя
curl -X DELETE "http://localhost:8000/api/cabinets/1/users/1/permissions" \
  -H "Authorization: Bearer $token" \
  -H "X-Cabinet-Id: 1" \
  -H "Content-Type: application/json" \
  -d '{"permission_ids": [1, 2]}'
```

#### Проверка middleware:
1. **Проверка без аутентификации** - должен возвращать 401:
   ```bash
   curl -X GET "http://localhost:8000/api/cabinets/1/users/1/permissions"
   ```

2. **Проверка без прав** - должен возвращать 403:
   ```bash
   # Создать пользователя без прав
   $user2 = App\Models\User::create(['phone' => '+71234567891', 'name' => 'Test User 2']);
   $token2 = $user2->createToken('test')->plainTextToken;
   
   curl -X GET "http://localhost:8000/api/cabinets/1/users/1/permissions" \
     -H "Authorization: Bearer $token2" \
     -H "X-Cabinet-Id: 1"
   ```

3. **Проверка с правами** - должен возвращать 200:
   ```bash
   curl -X GET "http://localhost:8000/api/cabinets/1/users/1/permissions" \
     -H "Authorization: Bearer $token" \
     -H "X-Cabinet-Id: 1"
   ```

#### Проверка кеширования:
```bash
php artisan tinker
# Проверить, что кеш создается
Cache::has('user_permissions:1:1');

# Проверить содержимое кеша
Cache::get('user_permissions:1:1');

# Очистить кеш
Cache::forget('user_permissions:1:1');
```

#### Проверка обновленных роутов:
1. **Обновление кабинета** - требует право cabinet.manage:
   ```bash
   curl -X PUT "http://localhost:8000/api/cabinets/1" \
     -H "Authorization: Bearer $token" \
     -H "X-Cabinet-Id: 1" \
     -H "Content-Type: application/json" \
     -d '{"name": "Updated Cabinet", "description": "Updated Description"}'
   ```

2. **Приглашение пользователя** - требует право user.invite:
   ```bash
   curl -X POST "http://localhost:8000/api/cabinets/1/invite" \
     -H "Authorization: Bearer $token" \
     -H "X-Cabinet-Id: 1" \
     -H "Content-Type: application/json" \
     -d '{"phone": "+71234567892", "role": "manager"}'
   ```

#### Проверка тестов:
```bash
# Запуск всех тестов
php run_tests.php

# Запуск тестов системы прав
vendor/bin/phpunit tests/Feature/CabinetUserPermissionTest.php

# Проверка покрытия тестами
vendor/bin/phpunit tests/Feature/ --coverage-text
```

### ✅ ШАГ 7: Проверка системы аудит-логирования

#### Проверка API эндпоинтов аудит-логирования:
1. **Роуты загружены** - выполнить команду:
   ```bash
   php artisan route:list --path=api/admin
   ```
   Должны отображаться роуты:
   - GET api/admin/audit-logs
   - GET api/admin/audit-logs/statistics
   - GET api/admin/audit-logs/recent

#### Проверка через HTTP запросы:
```bash
# Создать тестового пользователя и кабинет
php artisan tinker
$user = App\Models\User::create(['phone' => '+71234567890', 'name' => 'Test User']);
$cabinet = app(\App\Services\CabinetService::class)->createCabinet($user, 'Test Cabinet', 'Test Description');
$token = $user->createToken('test')->plainTextToken;
exit

# Получить аудит-логи
curl -X GET "http://localhost:8000/api/admin/audit-logs" \
  -H "Authorization: Bearer $token"

# Получить статистику логов
curl -X GET "http://localhost:8000/api/admin/audit-logs/statistics" \
  -H "Authorization: Bearer $token"

# Получить последние логи
curl -X GET "http://localhost:8000/api/admin/audit-logs/recent?limit=5" \
  -H "Authorization: Bearer $token"

# Фильтрация по событию
curl -X GET "http://localhost:8000/api/admin/audit-logs?event=cabinet.created" \
  -H "Authorization: Bearer $token"
```

#### Проверка генерации аудит-событий:
```bash
# Создать кабинет (должно сгенерировать событие)
curl -X POST "http://localhost:8000/api/cabinets" \
  -H "Authorization: Bearer $token" \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Cabinet", "description": "Test Description"}'

# Пригласить пользователя (должно сгенерировать событие)
curl -X POST "http://localhost:8000/api/cabinets/1/invite" \
  -H "Authorization: Bearer $token" \
  -H "X-Cabinet-Id: 1" \
  -H "Content-Type: application/json" \
  -d '{"phone": "+71234567891", "role": "manager"}'

# Назначить права (должно сгенерировать событие)
curl -X POST "http://localhost:8000/api/cabinets/1/users/1/permissions" \
  -H "Authorization: Bearer $token" \
  -H "X-Cabinet-Id: 1" \
  -H "Content-Type: application/json" \
  -d '{"permission_ids": [1, 2]}'
```

#### Проверка базы данных:
```bash
php artisan tinker
# Проверить, что аудит-логи записываются
App\Models\AuditLog::count();

# Проверить последние записи
App\Models\AuditLog::latest()->take(5)->get();

# Проверить события по типу
App\Models\AuditLog::where('event', 'cabinet.created')->get();
```

#### Проверка очереди задач:
```bash
# Запустить воркер очереди (в отдельном терминале)
php artisan queue:work

# Проверить, что задачи обрабатываются
php artisan queue:monitor
```

#### Проверка тестов:
```bash
# Запуск всех тестов
php run_tests.php

# Запуск тестов аудит-логирования
vendor/bin/phpunit tests/Feature/AuditLogTest.php

# Проверка покрытия тестами
vendor/bin/phpunit tests/Feature/ --coverage-text
```

### ✅ ШАГ 8: Проверка системы сообщений и уведомлений

#### Проверка API эндпоинтов системы сообщений:
1. **Роуты загружены** - выполнить команду:
   ```bash
   php artisan route:list --path=api/messages
   php artisan route:list --path=api/admin/messages
   ```
   Должны отображаться роуты:
   - GET api/messages - получение всех сообщений пользователя
   - GET api/messages/unread - получение непрочитанных сообщений
   - GET api/messages/statistics - статистика сообщений
   - POST api/messages/{message}/read - отметка о прочтении
   - POST api/messages/mark-all-read - отметка всех как прочитанных
   - Admin роуты: CRUD операции, toggle-active, statistics, types

#### Проверка через HTTP запросы:
```bash
# Создать тестового пользователя
php artisan tinker
$user = App\Models\User::create(['phone' => '+71234567890', 'name' => 'Test User']);
$token = $user->createToken('test')->plainTextToken;
exit

# Получить все сообщения пользователя
curl -X GET "http://localhost:8000/api/messages" \
  -H "Authorization: Bearer $token"

# Получить непрочитанные сообщения
curl -X GET "http://localhost:8000/api/messages/unread" \
  -H "Authorization: Bearer $token"

# Получить статистику сообщений
curl -X GET "http://localhost:8000/api/messages/statistics" \
  -H "Authorization: Bearer $token"

# Создать тестовое сообщение через MessageService
php artisan tinker
$messageService = app(\App\Services\MessageService::class);
$message = $messageService->sendPersistent('info', 'Test message', [$user->id], 'Test Title');
exit

# Отметить сообщение как прочитанное
curl -X POST "http://localhost:8000/api/messages/1/read" \
  -H "Authorization: Bearer $token"

# Отметить все сообщения как прочитанные
curl -X POST "http://localhost:8000/api/messages/mark-all-read" \
  -H "Authorization: Bearer $token"
```

#### Проверка SystemMessagesMiddleware:
```bash
# Создать непрочитанное сообщение
php artisan tinker
$user = App\Models\User::first();
$message = App\Models\Message::factory()->create(['type' => 'info', 'text' => 'System message', 'is_active' => true]);
$message->users()->attach($user->id, ['is_read' => false]);
exit

# Сделать любой API запрос - в заголовке X-System-Messages должно быть сообщение
curl -X GET "http://localhost:8000/api/messages" \
  -H "Authorization: Bearer $token" \
  -v
```

#### Проверка админских эндпоинтов:
```bash
# Получить все сообщения (админ)
curl -X GET "http://localhost:8000/api/admin/messages" \
  -H "Authorization: Bearer $token"

# Создать новое сообщение (админ)
curl -X POST "http://localhost:8000/api/admin/messages" \
  -H "Authorization: Bearer $token" \
  -H "Content-Type: application/json" \
  -d '{
    "type": "system",
    "title": "System Maintenance",
    "text": "Scheduled maintenance on Sunday",
    "recipients": [{"type": "all"}]
  }'

# Получить статистику сообщений (админ)
curl -X GET "http://localhost:8000/api/admin/messages-statistics" \
  -H "Authorization: Bearer $token"

# Получить типы сообщений (админ)
curl -X GET "http://localhost:8000/api/admin/message-types" \
  -H "Authorization: Bearer $token"
```

#### Проверка базы данных:
```bash
php artisan tinker
# Проверить, что сообщения создаются
App\Models\Message::count();

# Проверить получателей сообщений
App\Models\MessageRecipient::count();

# Проверить статус прочтения
App\Models\UserMessage::count();

# Проверить непрочитанные сообщения
App\Models\UserMessage::where('is_read', false)->count();
```

#### Проверка тестов:
```bash
# Запуск всех тестов
php run_tests.php

# Запуск тестов системы сообщений
vendor/bin/phpunit tests/Feature/MessageTest.php

# Проверка покрытия тестами
vendor/bin/phpunit tests/Feature/ --coverage-text
```

### ✅ ШАГ 10: Проверка фронтенда Main App

#### Проверка сборки и запуска:
1. **Сборка прошла успешно** - выполнить команду:
   ```bash
   npm run build
   ```
   Должна завершиться без ошибок

2. **Сервер запущен** - выполнить команду:
   ```bash
   php artisan serve
   ```
   Сервер должен запуститься на http://localhost:8000

#### Проверка в браузере:
1. **Открыть приложение** - перейти на http://localhost:8000
2. **Проверить редирект** - должен перенаправить на /login
3. **Проверить форму входа** - должна отображаться форма с полем телефона
4. **Проверить консоль** - в DevTools не должно быть ошибок JavaScript

#### Проверка Main Layout:
1. **Заголовок** - должен отображаться "Metrika3 Cabinet"
2. **Навигация** - боковая панель с пунктами "Дашборд" и "Настройки"
3. **Информация о пользователе** - отображается после авторизации
4. **Центр уведомлений** - иконка колокольчика в заголовке
5. **Переключатель кабинетов** - select для выбора кабинета (если несколько)

#### Проверка Dashboard:
1. **Приветствие** - персонализированное приветствие пользователя
2. **Статистические карточки** - кабинеты, пользователи, права, последний вход
3. **Быстрые действия** - кнопки для управления пользователями, журнала действий, сообщений
4. **Последние действия** - список из аудит-логов
5. **Загрузка данных** - данные должны загружаться с API

#### Проверка Settings:
1. **Вкладки** - "Пользователи" и "Права доступа"
2. **Таблица пользователей** - список пользователей кабинета с ролями и правами
3. **Приглашение пользователей** - модальное окно с формой
4. **Управление правами** - модальное окно для назначения прав
5. **API интеграция** - все действия должны работать с backend

#### Проверка страницы Кабинеты:
1. **Список кабинетов** - отображение всех кабинетов пользователя в виде карточек
2. **Создание кабинета** - модальное окно с формой (название, описание)
3. **Редактирование кабинета** - модальное окно для изменения данных
4. **Удаление кабинета** - подтверждение и удаление с проверкой прав
5. **Выбор кабинета** - кнопка "Выбрать" для установки текущего кабинета
6. **Права доступа** - владельцы кабинетов имеют все права автоматически
7. **Toast уведомления** - уведомления об успехе/ошибке операций
8. **API интеграция** - полная интеграция с backend API

#### Проверка Toast уведомлений:
1. **Отображение** - уведомления должны появляться в правом верхнем углу
2. **Типы** - success (зеленый), error (красный), warning (желтый), info (синий)
3. **Автоскрытие** - уведомления должны исчезать через 5 секунд
4. **Закрытие** - возможность закрыть уведомление вручную
5. **Ширина** - минимальная ширина 420px, максимальная 420px

#### Проверка центра уведомлений:
1. **Счетчик** - красный кружок с количеством непрочитанных сообщений
2. **Dropdown** - при клике открывается список сообщений
3. **Отметка о прочтении** - при клике на сообщение оно отмечается как прочитанное
4. **Клик вне области** - dropdown закрывается при клике вне его

#### Проверка переключения кабинетов:
1. **Выбор кабинета** - select с списком доступных кабинетов
2. **Смена кабинета** - при выборе другого кабинета данные обновляются
3. **Сохранение выбора** - выбранный кабинет сохраняется в localStorage
4. **Отображение текущего** - название текущего кабинета отображается в заголовке

#### Проверка API интеграции:
1. **Загрузка данных** - все данные загружаются с backend API
2. **Обработка ошибок** - ошибки отображаются в виде Toast уведомлений
3. **Loading состояния** - показываются индикаторы загрузки
4. **Авторизация** - токены автоматически добавляются в заголовки запросов

### ✅ ШАГ 9: Проверка панели администратора

#### Проверка API эндпоинтов админ-панели:
1. **Роуты загружены** - выполнить команду:
   ```bash
   php artisan route:list --path=api/admin
   ```
   Должны отображаться роуты:
   - POST api/admin/auth/register - регистрация администратора
   - POST api/admin/auth/login - вход администратора
   - POST api/admin/auth/logout - выход администратора
   - GET api/admin/auth/profile - профиль администратора
   - PUT api/admin/auth/profile - обновление профиля
   - GET api/admin/users - список пользователей
   - GET api/admin/cabinets - список кабинетов
   - GET api/admin/audit-logs - аудит-логи
   - GET api/admin/messages - сообщения
   - GET api/admin/statistics - общая статистика

#### Проверка через HTTP запросы:
```bash
# Создать тестового администратора
php artisan tinker
$admin = App\Models\AdminUser::create([
    'phone' => '+71234567890',
    'name' => 'Test Admin',
    'role' => 'admin'
]);
$token = $admin->createToken('test')->plainTextToken;
exit

# Войти в систему администратора
curl -X POST "http://localhost:8000/api/admin/auth/login" \
  -H "Content-Type: application/json" \
  -d '{"phone": "+71234567890"}'

# Получить профиль администратора
curl -X GET "http://localhost:8000/api/admin/auth/profile" \
  -H "Authorization: Bearer $token"

# Получить список пользователей
curl -X GET "http://localhost:8000/api/admin/users" \
  -H "Authorization: Bearer $token"

# Получить список кабинетов
curl -X GET "http://localhost:8000/api/admin/cabinets" \
  -H "Authorization: Bearer $token"

# Получить аудит-логи
curl -X GET "http://localhost:8000/api/admin/audit-logs" \
  -H "Authorization: Bearer $token"

# Получить статистику
curl -X GET "http://localhost:8000/api/admin/statistics" \
  -H "Authorization: Bearer $token"
```

#### Проверка прав доступа:
1. **Проверка без аутентификации** - должен возвращать 401:
   ```bash
   curl -X GET "http://localhost:8000/api/admin/users"
   ```

2. **Проверка с обычным пользователем** - должен возвращать 401:
   ```bash
   # Создать обычного пользователя
   $user = App\Models\User::create(['phone' => '+71234567891', 'name' => 'Test User']);
   $userToken = $user->createToken('test')->plainTextToken;
   
   curl -X GET "http://localhost:8000/api/admin/users" \
     -H "Authorization: Bearer $userToken"
   ```

3. **Проверка с администратором** - должен возвращать 200:
   ```bash
   curl -X GET "http://localhost:8000/api/admin/users" \
     -H "Authorization: Bearer $token"
   ```

#### Проверка управления пользователями:
```bash
# Получить детали пользователя
curl -X GET "http://localhost:8000/api/admin/users/1" \
  -H "Authorization: Bearer $token"

# Обновить пользователя
curl -X PUT "http://localhost:8000/api/admin/users/1" \
  -H "Authorization: Bearer $token" \
  -H "Content-Type: application/json" \
  -d '{"name": "Updated User", "phone": "+71234567891"}'

# Получить кабинеты пользователя
curl -X GET "http://localhost:8000/api/admin/users/1/cabinets" \
  -H "Authorization: Bearer $token"

# Получить аудит-логи пользователя
curl -X GET "http://localhost:8000/api/admin/users/1/audit-logs" \
  -H "Authorization: Bearer $token"
```

#### Проверка управления кабинетами:
```bash
# Получить детали кабинета
curl -X GET "http://localhost:8000/api/admin/cabinets/1" \
  -H "Authorization: Bearer $token"

# Обновить кабинет
curl -X PUT "http://localhost:8000/api/admin/cabinets/1" \
  -H "Authorization: Bearer $token" \
  -H "Content-Type: application/json" \
  -d '{"name": "Updated Cabinet", "description": "Updated Description"}'

# Получить пользователей кабинета
curl -X GET "http://localhost:8000/api/admin/cabinets/1/users" \
  -H "Authorization: Bearer $token"

# Получить аудит-логи кабинета
curl -X GET "http://localhost:8000/api/admin/cabinets/1/audit-logs" \
  -H "Authorization: Bearer $token"

# Передать права владения
curl -X POST "http://localhost:8000/api/admin/cabinets/1/transfer-ownership" \
  -H "Authorization: Bearer $token" \
  -H "Content-Type: application/json" \
  -d '{"new_owner_id": 2}'
```

#### Проверка управления сообщениями:
```bash
# Получить все сообщения
curl -X GET "http://localhost:8000/api/admin/messages" \
  -H "Authorization: Bearer $token"

# Создать новое сообщение
curl -X POST "http://localhost:8000/api/admin/messages" \
  -H "Authorization: Bearer $token" \
  -H "Content-Type: application/json" \
  -d '{
    "type": "system",
    "title": "System Maintenance",
    "text": "Scheduled maintenance on Sunday",
    "recipients": [{"type": "all"}]
  }'

# Получить статистику сообщений
curl -X GET "http://localhost:8000/api/admin/messages-statistics" \
  -H "Authorization: Bearer $token"

# Получить типы сообщений
curl -X GET "http://localhost:8000/api/admin/message-types" \
  -H "Authorization: Bearer $token"

# Переключить активность сообщения
curl -X PATCH "http://localhost:8000/api/admin/messages/1/toggle-active" \
  -H "Authorization: Bearer $token"
```

#### Проверка супер-администратора:
```bash
# Создать супер-администратора
$superAdmin = App\Models\AdminUser::create([
    'phone' => '+71234567892',
    'name' => 'Super Admin',
    'role' => 'super_admin'
]);
$superToken = $superAdmin->createToken('test')->plainTextToken;

# Управление администраторами (только для super_admin)
curl -X GET "http://localhost:8000/api/admin/admin-users" \
  -H "Authorization: Bearer $superToken"

# Создать нового администратора
curl -X POST "http://localhost:8000/api/admin/admin-users" \
  -H "Authorization: Bearer $superToken" \
  -H "Content-Type: application/json" \
  -d '{
    "phone": "+71234567893",
    "name": "New Admin",
    "role": "admin"
  }'

# Обновить роль администратора
curl -X PUT "http://localhost:8000/api/admin/admin-users/2/role" \
  -H "Authorization: Bearer $superToken" \
  -H "Content-Type: application/json" \
  -d '{"role": "super_admin"}'
```

#### Проверка базы данных:
```bash
php artisan tinker
# Проверить, что администраторы создаются
App\Models\AdminUser::count();

# Проверить роли администраторов
App\Models\AdminUser::where('role', 'super_admin')->count();
App\Models\AdminUser::where('role', 'admin')->count();

# Проверить токены администраторов
App\Models\AdminUser::first()->tokens()->count();
```

#### Проверка тестов:
```bash
# Запуск всех тестов
php run_tests.php

# Запуск тестов админ-панели
vendor/bin/phpunit tests/Feature/AdminTest.php

# Проверка покрытия тестами
vendor/bin/phpunit tests/Feature/ --coverage-text
```

---

## 🧪 Автотесты бэкенда

### Запуск тестов
```bash
# Запуск всех тестов
php run_tests.php

# Или через PHPUnit напрямую
vendor/bin/phpunit tests/Feature/

# Запуск конкретных тестов
vendor/bin/phpunit tests/Feature/AuthTest.php
vendor/bin/phpunit tests/Feature/CabinetTest.php
vendor/bin/phpunit tests/Feature/CabinetUserTest.php
vendor/bin/phpunit tests/Feature/PermissionTest.php
vendor/bin/phpunit tests/Feature/AuditTest.php
```

### Покрытие тестами
- ✅ **Аутентификация**: Регистрация, вход, верификация OTP, профиль, выход (9 тестов)
- ✅ **Кабинеты**: Создание, получение, обновление, удаление, права доступа (10 тестов)
- ✅ **Управление пользователями**: Приглашение, удаление, передача прав владения (11 тестов)
- ✅ **Система прав**: Роли, разрешения, проверка доступа (10 тестов)
- ✅ **Система прав (новые эндпоинты)**: Управление правами пользователей, кеширование, middleware (13 тестов)
- ✅ **Аудит**: Логирование действий, отслеживание изменений (11 тестов)
- ✅ **Аудит-логирование**: Репозиторий, Job, Events, Listeners, API (17 тестов)
- ✅ **Система сообщений**: API эндпоинты, MessageService, middleware (10 тестов)
- ✅ **Панель администратора**: Аутентификация, управление пользователями, кабинетами, логами, сообщениями (18 тестов)
- ✅ **Общее покрытие**: 109 тестов, 522 утверждения, 100% успешных тестов

### Требования к тестированию
- **ВСЕ** функции бэкенда должны быть покрыты тестами
- После каждого шага разработки запускать полный набор тестов
- Все тесты должны проходить успешно перед переходом к следующему шагу
- При добавлении новой функциональности создавать соответствующие тесты

---

## Примечания
- Проект находится в стадии активной разработки
- Реализованы ШАГИ 0-11 (включая полную систему прав, кеширование, аудит-логирование, систему сообщений, панель администратора и фронтенд админ-панели)
- Создана полная система автотестирования (109 тестов, 100% покрытие)
- Реализована гибкая система ролей и прав с middleware и кешированием
- Реализована система аудит-логирования с асинхронной записью через очередь задач
- Реализована система сообщений и уведомлений с поддержкой toast, persistent и broadcast сообщений
- Реализована панель администратора с полным управлением пользователями, кабинетами, логами и сообщениями
- Готов к переходу к следующему этапу разработки (ШАГ 10: Фронтенд - Main App (Базовый каркас и интеграция))

#### ШАГ 11: Фронтенд - Admin Panel ✅
- ✅ Создание Vue компонентов для админ-панели:
  - Login.vue - форма входа с номером телефона и OTP
  - Dashboard.vue - дашборд с общей статистикой и последними логами
  - UsersManagement.vue - управление пользователями с поиском и фильтрацией
  - CabinetsManagement.vue - управление кабинетами с поиском и фильтрацией
  - AuditLogs.vue - просмотр логов аудита с фильтрацией по событиям
  - MessagesManagement.vue - управление сообщениями и статистика
  - AdminPanel.vue - основной layout с навигацией и роутингом
- ✅ Создание Pinia store для админ-аутентификации:
  - useAdminAuthStore.js - управление состоянием авторизации администратора
  - Интеграция с Laravel Sanctum для токенов
  - Обработка ошибок и перенаправлений
- ✅ Настройка API клиента для админ-панели:
  - adminAxios.js - отдельный экземпляр Axios с baseURL /api/admin
  - Автоматическое добавление токена в заголовки
  - Обработка 401 ошибок с перенаправлением на логин
- ✅ Исправление проблем с роутингом:
  - Устранение дублирования baseURL в API запросах
  - Корректная настройка путей для всех админских эндпоинтов
- ✅ Обработка ошибок форматирования дат:
  - Добавлена проверка на null/undefined в функциях formatDate
  - Безопасное отображение дат во всех компонентах админ-панели
- ✅ Настройка IP-ограничения доступа:
  - Доступ к админ-панели только с IP, указанного в ADMIN_IP
  - Middleware для проверки IP-адреса администратора
  - Документация по настройке IP-ограничения в README.md
- ✅ Улучшения компонента PhoneInput:
  - Интеграция PhoneInput в админ-панель для единообразного интерфейса
  - Исправление позиционирования курсора - всегда в конце строки
  - Устранение дублирования символа "+" при удалении/вводе номера
  - Добавление поддержки disabled атрибута для блокировки ввода
  - Улучшенная валидация номера телефона с отображением ошибок

### Проверка ШАГ 11:
1. **Админ-панель доступна по адресу** `/admin`
2. **IP-ограничение работает** - доступ только с ADMIN_IP
3. **Авторизация работает** - вход по номеру телефона + OTP
4. **PhoneInput компонент работает корректно**:
   - Автоматическое форматирование номера при вводе
   - Курсор всегда остается в конце строки
   - Нет дублирования символа "+" при удалении/вводе
   - Валидация номера с отображением ошибок
   - Кнопка "Войти" активна только при корректном номере
5. **Все компоненты загружаются** без ошибок JavaScript
6. **API запросы корректны** - без дублирования baseURL
7. **Даты отображаются** корректно или показывают "Не указано"
8. **Навигация работает** между разделами админ-панели
9. **Статистика загружается** на дашборде
10. **Управление пользователями** - поиск, фильтрация, просмотр
11. **Управление кабинетами** - поиск, фильтрация, просмотр
12. **Логи аудита** - фильтрация по событиям, пагинация
13. **Управление сообщениями** - создание, редактирование, статистика

### Команды для проверки ШАГ 11:
```bash
# Создание тестового администратора
php artisan tinker --execute="App\Models\AdminUser::create(['phone' => '+71234567890', 'name' => 'Test Admin', 'role' => 'admin']);"

# Настройка IP в .env
echo "ADMIN_IP=127.0.0.1" >> .env

# Пересборка фронтенда
npm run build

# Запуск сервера
php artisan serve

# Проверка админ-панели
# Откройте http://localhost:8000/admin в браузере
# Введите номер +71234567890
# Проверьте все разделы админ-панели

# Тестирование PhoneInput компонента
# 1. Попробуйте ввести номер - должен форматироваться автоматически
# 2. Удалите все цифры - должно остаться только "+7"
# 3. Введите цифры заново - не должно быть дублирования "+"
# 4. Курсор должен оставаться в конце строки при вводе
# 5. Кнопка "Войти" должна быть активна только при корректном номере
```

### Готов к переходу к следующему этапу разработки (ШАГ 12: Документация и финализация)