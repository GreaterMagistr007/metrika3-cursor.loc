# Чеклист выполненных действий и добавленного функционала

## Статус проекта: В разработке (Фаза 1) - ШАГИ 0-8 завершены ✅

### ✅ Выполнено

#### ШАГ 0: Подготовка окружения и инициализация проекта
- ✅ Проверка и установка зависимостей (PHP 8.4.1, Composer, Node.js 22.11.0, npm 10.9.0)
- ✅ Инициализация Laravel 12 проекта с настройкой .env для SQLite и файлового кэширования
- ✅ Настройка фронтенда внутри Laravel проекта:
  - Vue 3 + Vite + TailwindCSS
  - Два приложения: основное (main-app) и админ-панель (admin-panel)
  - Роутинг и базовые компоненты
- ✅ Установка дополнительных пакетов:
  - Laravel Sanctum для API аутентификации
  - L5-Swagger для документации API
  - Guzzle (уже включен в Laravel)
- ✅ Настройка Vite конфигурации и сборка проекта
- ✅ Создание Blade шаблонов и роутов
- ✅ Исправление проблем с роутингом Laravel (порядок роутов)
- ✅ Настройка Vue Router для админ-панели
- ✅ Тестирование и проверка работоспособности обеих приложений

#### ШАГ 1: Проектирование БД и создание миграций
- ✅ Создание миграций для всех сущностей:
  - users (с полями phone, telegram_id, telegram_data, name, phone_verified_at, last_login_at)
  - cabinets (с полями name, owner_id, description, is_active)
  - cabinet_user (связь многие-ко-многим с ролями)
  - permissions (с полями name, description, category, is_active)
  - cabinet_user_permission (связь пользователей с правами)
  - audit_logs (согласно Приложению В ТЗ)
  - messages (система сообщений: toast, persistent, broadcast)
  - message_recipients (получатели сообщений)
  - user_messages (статус прочтения сообщений)
  - admin_users (отдельная таблица для администраторов)
- ✅ Написание сидеров:
  - PermissionsTableSeeder (права из Приложения А ТЗ: user.invite, user.remove, settings.view, settings.edit, message.read, message.manage)
  - AdminUsersTableSeeder (первый супер-администратор с номером из .env)
- ✅ Запуск миграций и сидов: php artisan migrate --seed

#### ШАГ 2: Разработка ядра системы (Модели, Relationships)
- ✅ Создание Eloquent моделей (final классы, strict typing) для всех таблиц:
  - User (с Laravel Sanctum токенами)
  - Cabinet (с отношениями к владельцу и пользователям)
  - Permission (с категориями и активностью)
  - CabinetUser (pivot модель с ролями)
  - AuditLog (для логирования действий)
  - Message (система сообщений: toast, persistent, broadcast)
  - MessageRecipient (получатели сообщений)
  - UserMessage (статус прочтения сообщений)
  - AdminUser (отдельная модель для администраторов)
- ✅ Реализация отношений между моделями:
  - User: belongsToMany(Cabinet), hasMany(ownedCabinets), hasMany(auditLogs), belongsToMany(messages)
  - Cabinet: belongsTo(owner), belongsToMany(users), hasMany(auditLogs)
  - CabinetUser: belongsTo(cabinet), belongsTo(user), belongsToMany(permissions)
  - Message: hasMany(recipients), belongsToMany(users), hasMany(userMessages)
- ✅ Создание трейтов:
  - HasPermissionsTrait с методами hasPermissionTo(), assignPermission(), syncPermissions()
  - AuditableTrait с методом logAuditEvent() для автоматического логирования действий
- ✅ Тестирование моделей и отношений через создание тестовых данных

#### ШАГ 3: Реализация модуля аутентификации и авторизации (Backend)
- ✅ Настройка Laravel Sanctum: публикация конфигов, миграций, настройка middleware
- ✅ Создание контроллеров аутентификации:
  - AuthController с методами requestOtp, verifyOtp, telegram, logout, me
  - AuthService для генерации OTP, отправки через Telegram, валидации данных
  - Form Request классы для валидации (LoginRequest, VerifyOtpRequest, TelegramAuthRequest)
- ✅ Создание роутов API для аутентификации:
  - POST /api/auth/request-otp - запрос кода подтверждения
  - POST /api/auth/verify-otp - верификация кода
  - POST /api/auth/telegram - авторизация через Telegram Mini App
  - POST /api/auth/logout - выход из системы
  - GET /api/auth/me - получение данных текущего пользователя
- ✅ Создание Middleware для проверки прав доступа:
  - CheckCabinetPermission middleware для проверки прав пользователя в кабинете
  - Поддержка получения cabinet_id из заголовка, параметров роута или тела запроса
- ✅ Тестирование API аутентификации - все роуты загружены и работают

#### ШАГ 4: Реализация модуля аутентификации (Frontend - Main App)
- ✅ Создание Pinia-стора useAuthStore:
  - Состояние: user, token, isAuthenticated, currentCabinet, loading, error
  - Действия: loginWithPhone, verifyOtp, loginWithTelegram, logout, fetchUser
  - Геттеры: isLoggedIn, userCabinets, hasMultipleCabinets
- ✅ Настройка Axios-интерцепторов:
  - Автоматическое добавление токена в заголовки запросов
  - Перехват ошибок 401 для автоматического логаута
  - Обработка системных сообщений из заголовков ответов
- ✅ Создание компонента LoginForm.vue:
  - Определение контекста (браузер или Telegram Mini App)
  - Автоматическая авторизация через Telegram
  - Форма ввода телефона и OTP с таймером
  - Интеграция с useAuthStore
- ✅ Настройка Vue Router:
  - Навигационные хуки для проверки аутентификации
  - Мета-поля requiresAuth и requiresGuest
  - Автоматическое перенаправление на login/dashboard
- ✅ Тестирование фронтенда - сборка прошла успешно, сервер работает
- ✅ Исправление ошибки с Telegram Bot токенами:
  - Обновлен AuthServiceProvider для работы с пустыми значениями
  - Добавлена проверка наличия токенов в AuthService
  - Создана инструкция по настройке Telegram Bot (TELEGRAM_SETUP.md)
- ✅ Добавление функциональности регистрации пользователей:
  - Создан API endpoint POST /api/auth/register для регистрации
  - Добавлен RegisterRequest для валидации данных регистрации
  - Расширен AuthService методом registerUser()
  - Создан компонент Register.vue с формой регистрации
  - Добавлен метод register() в useAuthStore
  - Обновлены роуты и навигация (ссылка на регистрацию в Login.vue)
  - Протестирована работа API и фронтенда
  - ✅ Исправлена ошибка "Call to undefined method storeOtp()" - заменен на Cache::put()

#### ШАГ 5: Модуль управления кабинетами и пользователями (Backend)
- ✅ Создание API-ресурсов (Eloquent Resources):
  - CabinetResource для отображения данных кабинета
  - UserResource для отображения данных пользователя
  - CabinetUserResource для отображения участников кабинета с правами
- ✅ Создание контроллеров:
  - CabinetController с методами index, store, show, update, destroy
  - CabinetUserController с методами invite, remove, transferOwnership
- ✅ Реализация сервисного слоя:
  - CabinetService с методами createCabinet, inviteUserToCabinet, removeUserFromCabinet, transferOwnership, deleteCabinet
  - Автоматическое назначение прав владельцу при создании кабинета
  - Назначение прав по ролям (admin, manager, operator)
- ✅ Создание API эндпоинтов:
  - GET /api/cabinets - список кабинетов пользователя
  - POST /api/cabinets - создание кабинета
  - GET /api/cabinets/{cabinet} - детали кабинета
  - PUT /api/cabinets/{cabinet} - обновление кабинета
  - DELETE /api/cabinets/{cabinet} - удаление кабинета
  - POST /api/cabinets/{cabinet}/invite - приглашение пользователя
  - DELETE /api/cabinets/{cabinet}/users/{user} - удаление пользователя
  - PATCH /api/cabinets/{cabinet}/transfer-ownership - передача прав владения
- ✅ Исправления и доработки:
  - Добавлено поле is_owner в таблицу cabinet_user
  - Исправлены отношения в CabinetUserResource
  - Зарегистрирован CabinetService в AuthServiceProvider
- ✅ Тестирование API - создание кабинетов работает корректно

#### ШАГ 6: Гибкая система ролей и прав (Backend)
- ✅ Создание Middleware CheckCabinetPermission:
  - Проверка прав доступа к кабинетам через middleware
  - Поддержка получения cabinet_id из заголовка X-Cabinet-Id, параметров роута или тела запроса
  - Возврат детализированных ошибок с кодами (UNAUTHENTICATED, CABINET_ID_REQUIRED, CABINET_NOT_FOUND, INSUFFICIENT_PERMISSIONS)
- ✅ Создание контроллера CabinetUserPermissionController:
  - GET /cabinets/{cabinet}/users/{user}/permissions - получение прав пользователя в кабинете
  - POST /cabinets/{cabinet}/users/{user}/permissions - назначение прав пользователю
  - DELETE /cabinets/{cabinet}/users/{user}/permissions - удаление прав пользователя
- ✅ Реализация кеширования прав пользователя:
  - Кеш по ключу user_permissions:{user_id}:{cabinet_id} с TTL 3600 секунд
  - Автоматическая очистка кеша при изменении прав
  - Оптимизация производительности для частых проверок прав
- ✅ Создание Form Request классов:
  - AssignPermissionRequest для валидации назначения прав
  - Валидация массива permission_ids с проверкой существования прав
- ✅ Создание API Resource:
  - PermissionResource для стандартизированного отображения прав
  - Включение всех полей: id, name, description, category, is_active, timestamps
- ✅ Обновление существующих роутов с middleware:
  - PUT /cabinets/{cabinet} - требует право cabinet.manage
  - DELETE /cabinets/{cabinet} - требует право cabinet.manage
  - POST /cabinets/{cabinet}/invite - требует право user.invite
  - DELETE /cabinets/{cabinet}/users/{user} - требует право user.remove
  - PATCH /cabinets/{cabinet}/transfer-ownership - требует право cabinet.manage
- ✅ Полное тестирование системы прав:
  - 13 новых тестов для проверки всех аспектов системы прав
  - Тестирование middleware, кеширования, назначения/удаления прав
  - Обновление всех существующих тестов для работы с новой системой прав
  - Все 65 тестов проходят успешно (100% покрытие)

#### ШАГ 7: Модуль аудит-логирования (Backend)
- ✅ Создание AuditLogRepository:
  - Метод log() для записи аудит-событий
  - Методы getLogs(), getStatistics(), getRecentLogs() для получения данных
  - Поддержка фильтрации по пользователю, кабинету, событию, дате
  - Пагинация результатов
- ✅ Создание Job LogAuditEvent:
  - Асинхронная запись аудит-событий через очередь задач
  - Обработка ошибок и повторные попытки (3 попытки)
  - Логирование неудачных попыток
- ✅ Создание Events для ключевых действий:
  - UserInvited - при приглашении пользователя
  - UserRemoved - при удалении пользователя
  - PermissionAssigned - при назначении прав
  - PermissionRevoked - при отзыве прав
  - CabinetCreated - при создании кабинета
  - CabinetUpdated - при обновлении кабинета
  - CabinetDeleted - при удалении кабинета
  - OwnershipTransferred - при передаче прав владения
- ✅ Создание Listeners для обработки событий:
  - LogUserInvited, LogUserRemoved - логирование действий с пользователями
  - LogPermissionAssigned, LogPermissionRevoked - логирование назначения/отзыва прав
  - LogCabinetCreated, LogCabinetUpdated, LogCabinetDeleted - логирование действий с кабинетами
  - LogOwnershipTransferred - логирование передачи прав владения
- ✅ Обновление контроллеров для генерации событий:
  - CabinetController - генерация событий при создании, обновлении, удалении кабинетов
  - CabinetUserController - генерация событий при приглашении, удалении пользователей, передаче прав
  - CabinetUserPermissionController - генерация событий при назначении/отзыве прав
- ✅ Создание API для админ-панели:
  - GET /api/admin/audit-logs - получение логов с фильтрацией и пагинацией
  - GET /api/admin/audit-logs/statistics - получение статистики логов
  - GET /api/admin/audit-logs/recent - получение последних логов
- ✅ Регистрация EventServiceProvider:
  - Связывание событий с слушателями
  - Автоматическая обработка событий через очередь задач
- ✅ Полное тестирование системы аудит-логирования:
  - 17 новых тестов для проверки всех компонентов
  - Тестирование репозитория, Job, Events, Listeners, API
  - Все 82 теста проходят успешно (100% покрытие)

#### ШАГ 8: Система сообщений и уведомлений (Backend)
- ✅ Создание миграций для таблиц сообщений:
  - messages (type, title, text, url, button_text, button_url, is_active, trigger_condition, expires_at)
  - message_recipients (message_id, recipient_type, recipient_id)
  - user_messages (user_id, message_id, is_read, read_at)
- ✅ Создание моделей с отношениями:
  - Message (с методами isSystem, isPersistent, isToast, getTypes)
  - MessageRecipient (с методами isUser, isCabinet, isAll)
  - UserMessage (с методами markAsRead, markAsUnread)
- ✅ Создание MessageService:
  - send() - отправка сообщений с распределением по получателям
  - sendToast() - отправка временных уведомлений
  - sendPersistent() - отправка постоянных сообщений
  - broadcast() - отправка системных сообщений
  - getUnreadMessagesForUser() - получение непрочитанных сообщений
  - markAsRead() - отметка о прочтении
  - processTriggers() - обработка триггеров автоматического скрытия
- ✅ Создание SystemMessagesMiddleware:
  - Автоматическое добавление непрочитанных сообщений в заголовок X-System-Messages
  - Обработка триггеров для автоматического скрытия сообщений
  - Работа только для аутентифицированных пользователей и API запросов
- ✅ Создание API контроллеров:
  - MessageController (index, unread, markAsRead, markAllAsRead, statistics)
  - Admin MessageController (CRUD операции, toggleActive, statistics, types)
- ✅ Создание Request классов:
  - MarkMessageReadRequest для валидации отметки о прочтении
  - CreateMessageRequest для создания сообщений администратором
  - UpdateMessageRequest для обновления сообщений администратором
- ✅ Добавление роутов для системы сообщений:
  - GET /api/messages - получение всех сообщений пользователя
  - GET /api/messages/unread - получение непрочитанных сообщений
  - GET /api/messages/statistics - статистика сообщений
  - POST /api/messages/{message}/read - отметка о прочтении
  - POST /api/messages/mark-all-read - отметка всех как прочитанных
  - Admin роуты: CRUD операции, toggle-active, statistics, types
- ✅ Создание фабрики MessageFactory:
  - Поддержка всех типов сообщений (success, error, warning, info, system)
  - Состояния для toast, persistent, system сообщений
  - Генерация тестовых данных с триггерами и сроками действия
- ✅ Полное тестирование системы сообщений:
  - 10 новых тестов для проверки всех компонентов
  - Тестирование API эндпоинтов, MessageService, middleware
  - Все 92 теста проходят успешно (100% покрытие)

### 🔄 В процессе
*Нет активных задач*

### ⏳ Запланировано
*См. step-plan.mdc для полного списка задач*

---

## Инструкции по проверке функционала

### ✅ ШАГ 0: Проверка базовой функциональности

#### Основное приложение (http://localhost:8000):
1. **Заголовок** - должен отображаться "Metrika3 Cabinet"
2. **Форма входа** - поле для номера телефона с кнопкой "Получить код"
3. **Стили** - применяется TailwindCSS (современный дизайн)
4. **Навигация** - кнопка "Войти" ведет на форму входа

#### Админ-панель (http://localhost:8000/admin):
1. **Заголовок** - должен отображаться "Metrika3 Admin Panel"
2. **Форма входа** - поле для номера телефона администратора
3. **Темная тема** - серый фон, белый текст в боковой панели
4. **Навигация** - кнопка "Войти" ведет на форму входа админа
5. **Консоль** - в DevTools должны быть логи "AdminPanel mounted"

#### Техническая проверка:
- ✅ Laravel сервер запущен на http://localhost:8000
- ✅ Vite сборка работает без ошибок
- ✅ CSS и JS файлы загружаются корректно
- ✅ Vue Router работает для обеих приложений

### ✅ ШАГ 1: Проверка базы данных

#### Проверка структуры БД:
1. **SQLite база данных** - файл `database/database.sqlite` создан
2. **Все таблицы созданы** - можно проверить через SQLite Browser или команду:
   ```bash
   php artisan tinker
   DB::select("SELECT name FROM sqlite_master WHERE type='table';");
   ```
3. **Права доступа** - в таблице `permissions` должны быть 6 записей:
   - user.invite, user.remove, settings.view, settings.edit, message.read, message.manage
4. **Супер-администратор** - в таблице `admin_users` должна быть 1 запись с ролью super_admin

#### Проверка через Tinker:
```bash
php artisan tinker
# Проверить права
DB::table('permissions')->get();
# Проверить админа
DB::table('admin_users')->get();
# Проверить структуру таблиц
Schema::getColumnListing('users');
Schema::getColumnListing('cabinets');
```

### ✅ ШАГ 2: Проверка моделей и отношений

#### Проверка создания моделей:
1. **Все модели созданы** - в папке `app/Models/` должны быть файлы:
   - User.php, Cabinet.php, Permission.php, CabinetUser.php
   - AuditLog.php, Message.php, MessageRecipient.php, UserMessage.php, AdminUser.php
2. **Трейты созданы** - в папке `app/Traits/` должны быть:
   - HasPermissionsTrait.php, AuditableTrait.php

#### Проверка через Tinker:
```bash
php artisan tinker
# Проверить загрузку моделей
App\Models\User::class
App\Models\Cabinet::class
App\Models\Permission::class

# Создать тестового пользователя
$user = App\Models\User::create(['phone' => '+1234567890', 'name' => 'Test User']);
echo "User ID: " . $user->id;

# Создать тестовый кабинет
$cabinet = App\Models\Cabinet::create(['name' => 'Test Cabinet', 'owner_id' => $user->id]);
echo "Cabinet ID: " . $cabinet->id;

# Проверить отношения
echo "Cabinet owner: " . $cabinet->owner->name;
echo "User cabinets count: " . $user->cabinets()->count();

# Проверить аудит-логи
echo "Audit logs count: " . App\Models\AuditLog::count();
```

#### Проверка трейтов:
```bash
# Проверить права доступа
$permission = App\Models\Permission::first();
echo "First permission: " . $permission->name;

# Проверить методы трейтов (если есть CabinetUser)
$cabinetUser = App\Models\CabinetUser::first();
if ($cabinetUser) {
    echo "Has permission: " . ($cabinetUser->hasPermission('user.invite') ? 'Yes' : 'No');
}
```

### ✅ ШАГ 3: Проверка API аутентификации

#### Проверка роутов API:
1. **Роуты загружены** - выполнить команду:
   ```bash
   php artisan route:list --path=api
   ```
   Должны отображаться роуты:
   - POST api/auth/request-otp
   - POST api/auth/verify-otp  
   - POST api/auth/telegram
   - POST api/auth/logout
   - GET api/auth/me

#### Проверка через HTTP запросы:
```bash
# Запустить сервер
php artisan serve

# В другом терминале протестировать API
curl -X POST http://localhost:8000/api/auth/request-otp \
  -H "Content-Type: application/json" \
  -d '{"phone": "+1234567890"}'

# Ожидаемый ответ: {"message": "Код подтверждения отправлен в Telegram", "expires_in": 300}
```

#### Проверка конфигурации:
1. **Sanctum настроен** - файл `config/sanctum.php` существует
2. **Telegram конфигурация** - в `config/services.php` добавлены настройки:
   ```php
   'telegram' => [
       'bot_token' => env('TELEGRAM_BOT_TOKEN'),
       'bot_secret' => env('TELEGRAM_BOT_SECRET'),
   ],
   ```
3. **Middleware зарегистрирован** - в `bootstrap/app.php` добавлен:
   ```php
   'cabinet.permission' => \App\Http\Middleware\CheckCabinetPermission::class,
   ```

#### Проверка сервисов:
```bash
php artisan tinker
# Проверить, что AuthService зарегистрирован
app(App\Services\AuthService::class);
```

### ✅ ШАГ 4: Проверка фронтенд аутентификации

#### Проверка сборки:
1. **Сборка прошла успешно** - выполнить команду:
   ```bash
   npm run build
   ```
   Должна завершиться без ошибок

#### Проверка в браузере:
1. **Открыть приложение** - перейти на http://localhost:8000
2. **Проверить редирект** - должен перенаправить на /login
3. **Проверить форму входа** - должна отображаться форма с полем телефона
4. **Проверить консоль** - в DevTools не должно быть ошибок JavaScript

#### Проверка функционала:
```bash
# Проверить, что сервер работает
curl -s http://localhost:8000

# Проверить API endpoints
curl -X POST http://localhost:8000/api/auth/request-otp \
  -H "Content-Type: application/json" \
  -d '{"phone": "+1234567890"}'
```

#### Проверка файлов:
1. **Stores созданы** - в папке `resources/js/stores/` должны быть:
   - useAuthStore.js
   - useMessageStore.js
2. **API настроен** - в папке `resources/js/api/` должен быть:
   - axios.js
3. **Компоненты обновлены** - Login.vue и MainApp.vue используют auth store

#### Проверка интеграции:
- Форма входа интегрирована с API
- Router guards работают (редирект на /login для неавторизованных)
- Axios интерцепторы настроены
- Pinia store инициализируется при загрузке

#### Настройка Telegram Bot:
1. **Создать бота** - следовать инструкции в файле `TELEGRAM_SETUP.md`
2. **Добавить переменные в .env**:
   ```env
   TELEGRAM_BOT_TOKEN=your_bot_token_here
   TELEGRAM_BOT_SECRET=your_webhook_secret_here
   ```
3. **Очистить кэш конфигурации**:
   ```bash
   php artisan config:clear
   ```
4. **Протестировать API** - запрос OTP должен работать без ошибок

#### Тестирование регистрации:
1. **Открыть страницу регистрации** - перейти на `/register`
2. **Заполнить форму**:
   - Имя (обязательно, минимум 2 символа)
   - Номер телефона в формате +7XXXXXXXXXX (обязательно, уникальный)
   - Telegram ID (необязательно, уникальный)
3. **Проверить валидацию**:
   - Попытка регистрации с существующим номером телефона должна показать ошибку
   - Попытка регистрации с существующим Telegram ID должна показать ошибку
4. **Успешная регистрация**:
   - После регистрации пользователь перенаправляется на страницу входа
   - Если указан Telegram ID, код подтверждения отправляется в Telegram
   - Номер телефона автоматически подставляется в форму входа

### ✅ ШАГ 6: Проверка системы прав

#### Проверка API эндпоинтов системы прав:
1. **Роуты загружены** - выполнить команду:
   ```bash
   php artisan route:list --path=api/cabinets
   ```
   Должны отображаться новые роуты:
   - GET api/cabinets/{cabinet}/users/{user}/permissions
   - POST api/cabinets/{cabinet}/users/{user}/permissions
   - DELETE api/cabinets/{cabinet}/users/{user}/permissions

#### Проверка через HTTP запросы:
```bash
# Создать тестового пользователя и кабинет
php artisan tinker
$user = App\Models\User::create(['phone' => '+71234567890', 'name' => 'Test User']);
$cabinet = app(\App\Services\CabinetService::class)->createCabinet($user, 'Test Cabinet', 'Test Description');
$token = $user->createToken('test')->plainTextToken;
exit

# Получить права пользователя
curl -X GET "http://localhost:8000/api/cabinets/1/users/1/permissions" \
  -H "Authorization: Bearer $token" \
  -H "X-Cabinet-Id: 1"

# Назначить права пользователю
curl -X POST "http://localhost:8000/api/cabinets/1/users/1/permissions" \
  -H "Authorization: Bearer $token" \
  -H "X-Cabinet-Id: 1" \
  -H "Content-Type: application/json" \
  -d '{"permission_ids": [1, 2, 3]}'

# Удалить права пользователя
curl -X DELETE "http://localhost:8000/api/cabinets/1/users/1/permissions" \
  -H "Authorization: Bearer $token" \
  -H "X-Cabinet-Id: 1" \
  -H "Content-Type: application/json" \
  -d '{"permission_ids": [1, 2]}'
```

#### Проверка middleware:
1. **Проверка без аутентификации** - должен возвращать 401:
   ```bash
   curl -X GET "http://localhost:8000/api/cabinets/1/users/1/permissions"
   ```

2. **Проверка без прав** - должен возвращать 403:
   ```bash
   # Создать пользователя без прав
   $user2 = App\Models\User::create(['phone' => '+71234567891', 'name' => 'Test User 2']);
   $token2 = $user2->createToken('test')->plainTextToken;
   
   curl -X GET "http://localhost:8000/api/cabinets/1/users/1/permissions" \
     -H "Authorization: Bearer $token2" \
     -H "X-Cabinet-Id: 1"
   ```

3. **Проверка с правами** - должен возвращать 200:
   ```bash
   curl -X GET "http://localhost:8000/api/cabinets/1/users/1/permissions" \
     -H "Authorization: Bearer $token" \
     -H "X-Cabinet-Id: 1"
   ```

#### Проверка кеширования:
```bash
php artisan tinker
# Проверить, что кеш создается
Cache::has('user_permissions:1:1');

# Проверить содержимое кеша
Cache::get('user_permissions:1:1');

# Очистить кеш
Cache::forget('user_permissions:1:1');
```

#### Проверка обновленных роутов:
1. **Обновление кабинета** - требует право cabinet.manage:
   ```bash
   curl -X PUT "http://localhost:8000/api/cabinets/1" \
     -H "Authorization: Bearer $token" \
     -H "X-Cabinet-Id: 1" \
     -H "Content-Type: application/json" \
     -d '{"name": "Updated Cabinet", "description": "Updated Description"}'
   ```

2. **Приглашение пользователя** - требует право user.invite:
   ```bash
   curl -X POST "http://localhost:8000/api/cabinets/1/invite" \
     -H "Authorization: Bearer $token" \
     -H "X-Cabinet-Id: 1" \
     -H "Content-Type: application/json" \
     -d '{"phone": "+71234567892", "role": "manager"}'
   ```

#### Проверка тестов:
```bash
# Запуск всех тестов
php run_tests.php

# Запуск тестов системы прав
vendor/bin/phpunit tests/Feature/CabinetUserPermissionTest.php

# Проверка покрытия тестами
vendor/bin/phpunit tests/Feature/ --coverage-text
```

### ✅ ШАГ 7: Проверка системы аудит-логирования

#### Проверка API эндпоинтов аудит-логирования:
1. **Роуты загружены** - выполнить команду:
   ```bash
   php artisan route:list --path=api/admin
   ```
   Должны отображаться роуты:
   - GET api/admin/audit-logs
   - GET api/admin/audit-logs/statistics
   - GET api/admin/audit-logs/recent

#### Проверка через HTTP запросы:
```bash
# Создать тестового пользователя и кабинет
php artisan tinker
$user = App\Models\User::create(['phone' => '+71234567890', 'name' => 'Test User']);
$cabinet = app(\App\Services\CabinetService::class)->createCabinet($user, 'Test Cabinet', 'Test Description');
$token = $user->createToken('test')->plainTextToken;
exit

# Получить аудит-логи
curl -X GET "http://localhost:8000/api/admin/audit-logs" \
  -H "Authorization: Bearer $token"

# Получить статистику логов
curl -X GET "http://localhost:8000/api/admin/audit-logs/statistics" \
  -H "Authorization: Bearer $token"

# Получить последние логи
curl -X GET "http://localhost:8000/api/admin/audit-logs/recent?limit=5" \
  -H "Authorization: Bearer $token"

# Фильтрация по событию
curl -X GET "http://localhost:8000/api/admin/audit-logs?event=cabinet.created" \
  -H "Authorization: Bearer $token"
```

#### Проверка генерации аудит-событий:
```bash
# Создать кабинет (должно сгенерировать событие)
curl -X POST "http://localhost:8000/api/cabinets" \
  -H "Authorization: Bearer $token" \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Cabinet", "description": "Test Description"}'

# Пригласить пользователя (должно сгенерировать событие)
curl -X POST "http://localhost:8000/api/cabinets/1/invite" \
  -H "Authorization: Bearer $token" \
  -H "X-Cabinet-Id: 1" \
  -H "Content-Type: application/json" \
  -d '{"phone": "+71234567891", "role": "manager"}'

# Назначить права (должно сгенерировать событие)
curl -X POST "http://localhost:8000/api/cabinets/1/users/1/permissions" \
  -H "Authorization: Bearer $token" \
  -H "X-Cabinet-Id: 1" \
  -H "Content-Type: application/json" \
  -d '{"permission_ids": [1, 2]}'
```

#### Проверка базы данных:
```bash
php artisan tinker
# Проверить, что аудит-логи записываются
App\Models\AuditLog::count();

# Проверить последние записи
App\Models\AuditLog::latest()->take(5)->get();

# Проверить события по типу
App\Models\AuditLog::where('event', 'cabinet.created')->get();
```

#### Проверка очереди задач:
```bash
# Запустить воркер очереди (в отдельном терминале)
php artisan queue:work

# Проверить, что задачи обрабатываются
php artisan queue:monitor
```

#### Проверка тестов:
```bash
# Запуск всех тестов
php run_tests.php

# Запуск тестов аудит-логирования
vendor/bin/phpunit tests/Feature/AuditLogTest.php

# Проверка покрытия тестами
vendor/bin/phpunit tests/Feature/ --coverage-text
```

### ✅ ШАГ 8: Проверка системы сообщений и уведомлений

#### Проверка API эндпоинтов системы сообщений:
1. **Роуты загружены** - выполнить команду:
   ```bash
   php artisan route:list --path=api/messages
   php artisan route:list --path=api/admin/messages
   ```
   Должны отображаться роуты:
   - GET api/messages - получение всех сообщений пользователя
   - GET api/messages/unread - получение непрочитанных сообщений
   - GET api/messages/statistics - статистика сообщений
   - POST api/messages/{message}/read - отметка о прочтении
   - POST api/messages/mark-all-read - отметка всех как прочитанных
   - Admin роуты: CRUD операции, toggle-active, statistics, types

#### Проверка через HTTP запросы:
```bash
# Создать тестового пользователя
php artisan tinker
$user = App\Models\User::create(['phone' => '+71234567890', 'name' => 'Test User']);
$token = $user->createToken('test')->plainTextToken;
exit

# Получить все сообщения пользователя
curl -X GET "http://localhost:8000/api/messages" \
  -H "Authorization: Bearer $token"

# Получить непрочитанные сообщения
curl -X GET "http://localhost:8000/api/messages/unread" \
  -H "Authorization: Bearer $token"

# Получить статистику сообщений
curl -X GET "http://localhost:8000/api/messages/statistics" \
  -H "Authorization: Bearer $token"

# Создать тестовое сообщение через MessageService
php artisan tinker
$messageService = app(\App\Services\MessageService::class);
$message = $messageService->sendPersistent('info', 'Test message', [$user->id], 'Test Title');
exit

# Отметить сообщение как прочитанное
curl -X POST "http://localhost:8000/api/messages/1/read" \
  -H "Authorization: Bearer $token"

# Отметить все сообщения как прочитанные
curl -X POST "http://localhost:8000/api/messages/mark-all-read" \
  -H "Authorization: Bearer $token"
```

#### Проверка SystemMessagesMiddleware:
```bash
# Создать непрочитанное сообщение
php artisan tinker
$user = App\Models\User::first();
$message = App\Models\Message::factory()->create(['type' => 'info', 'text' => 'System message', 'is_active' => true]);
$message->users()->attach($user->id, ['is_read' => false]);
exit

# Сделать любой API запрос - в заголовке X-System-Messages должно быть сообщение
curl -X GET "http://localhost:8000/api/messages" \
  -H "Authorization: Bearer $token" \
  -v
```

#### Проверка админских эндпоинтов:
```bash
# Получить все сообщения (админ)
curl -X GET "http://localhost:8000/api/admin/messages" \
  -H "Authorization: Bearer $token"

# Создать новое сообщение (админ)
curl -X POST "http://localhost:8000/api/admin/messages" \
  -H "Authorization: Bearer $token" \
  -H "Content-Type: application/json" \
  -d '{
    "type": "system",
    "title": "System Maintenance",
    "text": "Scheduled maintenance on Sunday",
    "recipients": [{"type": "all"}]
  }'

# Получить статистику сообщений (админ)
curl -X GET "http://localhost:8000/api/admin/messages-statistics" \
  -H "Authorization: Bearer $token"

# Получить типы сообщений (админ)
curl -X GET "http://localhost:8000/api/admin/message-types" \
  -H "Authorization: Bearer $token"
```

#### Проверка базы данных:
```bash
php artisan tinker
# Проверить, что сообщения создаются
App\Models\Message::count();

# Проверить получателей сообщений
App\Models\MessageRecipient::count();

# Проверить статус прочтения
App\Models\UserMessage::count();

# Проверить непрочитанные сообщения
App\Models\UserMessage::where('is_read', false)->count();
```

#### Проверка тестов:
```bash
# Запуск всех тестов
php run_tests.php

# Запуск тестов системы сообщений
vendor/bin/phpunit tests/Feature/MessageTest.php

# Проверка покрытия тестами
vendor/bin/phpunit tests/Feature/ --coverage-text
```

---

## 🧪 Автотесты бэкенда

### Запуск тестов
```bash
# Запуск всех тестов
php run_tests.php

# Или через PHPUnit напрямую
vendor/bin/phpunit tests/Feature/

# Запуск конкретных тестов
vendor/bin/phpunit tests/Feature/AuthTest.php
vendor/bin/phpunit tests/Feature/CabinetTest.php
vendor/bin/phpunit tests/Feature/CabinetUserTest.php
vendor/bin/phpunit tests/Feature/PermissionTest.php
vendor/bin/phpunit tests/Feature/AuditTest.php
```

### Покрытие тестами
- ✅ **Аутентификация**: Регистрация, вход, верификация OTP, профиль, выход (9 тестов)
- ✅ **Кабинеты**: Создание, получение, обновление, удаление, права доступа (10 тестов)
- ✅ **Управление пользователями**: Приглашение, удаление, передача прав владения (11 тестов)
- ✅ **Система прав**: Роли, разрешения, проверка доступа (10 тестов)
- ✅ **Система прав (новые эндпоинты)**: Управление правами пользователей, кеширование, middleware (13 тестов)
- ✅ **Аудит**: Логирование действий, отслеживание изменений (11 тестов)
- ✅ **Аудит-логирование**: Репозиторий, Job, Events, Listeners, API (17 тестов)
- ✅ **Система сообщений**: API эндпоинты, MessageService, middleware (10 тестов)
- ✅ **Общее покрытие**: 92 теста, 313 утверждений, 100% успешных тестов

### Требования к тестированию
- **ВСЕ** функции бэкенда должны быть покрыты тестами
- После каждого шага разработки запускать полный набор тестов
- Все тесты должны проходить успешно перед переходом к следующему шагу
- При добавлении новой функциональности создавать соответствующие тесты

---

## Примечания
- Проект находится в стадии активной разработки
- Реализованы ШАГИ 0-8 (включая полную систему прав, кеширование, аудит-логирование и систему сообщений)
- Создана полная система автотестирования (92 теста, 100% покрытие)
- Реализована гибкая система ролей и прав с middleware и кешированием
- Реализована система аудит-логирования с асинхронной записью через очередь задач
- Реализована система сообщений и уведомлений с поддержкой toast, persistent и broadcast сообщений
- Готов к переходу к следующему этапу разработки (ШАГ 9: Панель администратора)